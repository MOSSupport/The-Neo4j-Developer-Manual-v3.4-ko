
### 3.6.1. Cypher 쿼리 옵션

```
이 섹션에서는 Cypher에서 이용가능한 쿼리 옵션에 대해 다룹니다. 
```

쿼리 실행은 쿼리 옵션에서 조절할 수 있습니다. 한 개이상의 옵션을 사용하려면, ```CYPHER query-option [further-query-options] query```와 같이 쿼리에 Cypher를 추가하고 접두어로 쿼리 옵션을 사용해야 합니다. 

#### 3.6.1.1. Cypher 버전

일반적으로, 쿼리를 실행할 때 Cypher 컴파일러 이전 버전을 사용해야한다는 요구사항이 있습니다. 아래는 이용가능한 버전입니다:

| 쿼리 옵션  | 설명                                                         | 디폴트(Default)? |
| ---------- | ------------------------------------------------------------ | ---------------- |
| ```2.3``` | 쿼리가 Neo4j Cypher 2.3을 사용하도록 합니다.                 |                  |
| ```3.3```  | 쿼리가 Neo4j Cypher 3.3을 사용하도록 합니다.                 |                  |
| ```3.4```  | 쿼리가 Neo4j Cypher 3.4을 디폴트로 사용하도록 합니다. 이 옵션을 명시적으로 사용할 필요는 없습니다. | X                |


#### 3.6.1.2. Cypher 플래너 

각 쿼리는 *execution planner*에 의해서 실행 계획으로 변환됩니다. Neo4j가 쿼리를 실행할 때 수행할 작업을 알려줍니다.  

Neo4j는 ('cost'플래너라고 알려진) 비용-기반 실행 계획 전략을 사용합니다: Neo4j 전략 서비스는 대안 계획 비용을 할당하고 가장 저렴한 것을 선택합니다. 

Neo4j 3.2 이전의 모든 버전은 규칙을 사용하여 실행 플랜을 작성할 때 쓰이는 룰 기반 플랜을 포함합니다. 이 플래너는 사용가능한 인덱스를 고려했지만, 통계 정보를 사용하여 쿼리 컴파일을 나타내지는 않았습니다. 룰 플래너는 비용 플래너와 비교했을 때 실행 성능이 떨어지기에 Neo4j 3.2에서 제거되었습니다. 

| 옵션               | 설명                                                         | 디폴트(default)? |
| ------------------ | ------------------------------------------------------------ | ---------------- |
| ```planner=rule``` | 쿼리가 룰 플래너를 사용하도록하여 쿼리가 Cypher 3.1로 복귀하도록 합니다. |                  |
| ```planner=cost``` | Neo4j 3.4는 모든 쿼리에서 비용 플래너를 사용합니다. 그래서 이 옵션을 명시적으로 사용할 필요는 없습니다. | X                |


```cypher.planner``` 설정을 사용해서 기본 플래너를 변경할 수도 있습니다. [작동 메뉴얼->환경 설정 참조](https://neo4j.com/docs/operations-manual/3.4/reference/configuration-settings/#config_cypher.planner)

실행 플랜에서 어떤 플래너가 쓰였는지 확인할 수 있습니다. 

Cypher 실행 플랜을 세울 때 사용할 수 있는 인덱스를 확인하고자 스키마를 체크합니다. 인덱스는 스키마가 변화하기 전까지만 유효하기 떄문에 인덱스를 추가하거나 삭제하면 실행 계획 캐시가 플러시됩니다. 

#### 3.6.1.3. Cypher 런타임

실행 플랜을 사용하면, 쿼리 엔진 또는 런타임에서 쿼리가 실행됩니다.- 기록은 반환됩니다- Neo4j 앤터프라이즈 또는 Neo4j 커뮤니티 사용 여부에 따라, 이용 가능한 3가지 종류의 런타임이 있씁니다. 

**Interpreted**
이 런타임에서 실행 계획의 연산자는 하나의 트리에 묶여 있으며, 리프가 아닌 각 연산자는 하나 또는 두 개의 하위 연산자에서 피드합니다. 따라서 트리는 중첩 반복자로 구성되며, 레코드는 상위 반복자에서 파이프 라인 방식으로 스트리밍 됩니다. 

**Slotted**

이것은 레코드가 반복자로 스트링된 다는 것을 포함하는 추가적인 최적화를 제외하고 Interpreted 런타임과 유사합니다. 이 결과로 쿼리 성능과 메모리 사용의 개선됩니다. 이것은 `빠른 해석`런타임으로 생각할 수도 있습니다.

이 slotted 런타임은 Neo4j 앤터프라이즈에서만 이용할 수 있습니다.

**Compiled**

알고리즘은 성능과 메모리 사용에 최적화 된 새로운 조합 및 실행 순서를 생성하기 위해 실행 계획에서 연산자를 그룹화할 때 사용됩니다. 이것이 대부분의 경우에 우수한 성능을 가져야하지만(interpreted 와 slotted 런타임에서), 이것은 아직 발전 중이며 모든 연산자 또는 쿼리를 지원하지 않습니다(slotted 런타임은 모든 연산자와 query를 커버합니다.).

컴파일된 런타임은 Neo4j 앤터프라이즈 버전에서만 이용할 수 있습니다. 

앤터프라이즈 버전에서, 쿼리 실행 엔진 메커니즘은 컴파일된 런타임을 먼저 시도하고 쿼리를 지원하지 않으면 모든 쿼리를 지원하는 슬롯 런타임으로 폴백하는 것입니다. 

| 옵션                       | 설명                                                         | 디폴트?(Default)                                             |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ``` runtime=interpreted``` | 쿼리 실행 엔진이 Interpreted 런타임을 사용하도록 합니다.     | 이것은 확실하게 요구 받지 않을 경우 앤터프라이즈 버전에서 사용되지 않습니다.  커뮤니티 버전의 모든 쿼리에서만 가능한 옵션입니다. |
| ``` runtime=slotted```     | 쿼리 실행 엔진이 slotted 런타임을 사용하도록 합니다.         | 앤터프라이즈 버전에서 런타임=컴파일에서 지원하지 않는 쿼리의 기본 옵션입니다. |
| ``` runtime=compiled```    | 쿼리 실행 엔진이 쿼리를 지원할 경우 컴파일된 런타임을 사용하도록 합니다. 반대의 경우, 엔진은 slotted 런타임으로 폴백됩니다. | 앤터프라이즈 버전에서 사용되는 쿼리의 기본 옵션입니다.       |